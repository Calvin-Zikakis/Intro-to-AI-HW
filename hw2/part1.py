import GAinspector
import numpy as np
from utils import *
import random

def randomGenome(length):
    """
    :param length:
    :return: string, random binary digit
    """
    """Your Code Here"""
    bitstring = ""
    for i in range(length):
        random_choice = np.random.randint(0,2)
        bitstring = bitstring + str(random_choice)
    return bitstring
    #returns a random bitstring of specified length




def makePopulation(size, length):
    """
    :param size - of population:
    :param length - of genome
    :return: list of length size containing genomes of length length
    """

    """Your Code Here"""

    population = []
    i = 0
    while i < size:
        population.append(randomGenome(length))
        #loop over size to get amount of genomes required. Build genomes and append to list
        i+=1
    return population


def fitness(genome):
    """
    :param genome: 
    :return: the fitness value of a genome
    """

    genome_int = int(genome)
    return sum(map(int, str(genome_int)))
    #fit function is defined as sum of values. use sum()

def evaluateFitness(population):
    """
    :param population: 
    :return: a pair of values: the average fitness of the population as a whole and the fitness of the best individual in the population.
    """
    current_best = 0
    total_fitness = 0
    amount = 0

    for count, item in enumerate(population):
        gene = fitness(item)
        total_fitness = total_fitness + gene
        if (gene > current_best):
            current_best = gene
        amount = count

    average = float(total_fitness)/(amount+1)
    return average, current_best


def crossover(genome1, genome2):
    """
    :param genome1:
    :param genome2:
    :return: two new genomes produced by crossing over the given genomes at a random crossover point.
    """
    random_point = np.random.randint(1, len(genome1))

    child_1 = genome1[:random_point] + genome2[random_point:]
    child_2 = genome2[:random_point] + genome1[random_point:]
    return child_1, child_2



def mutate(genome, mutationRate):
    """
    :param genome:
    :param mutationRate:
    :return: a new mutated version of the given genome.
    """
    genome_list = list(genome)
    mutated_list = []
    if mutationRate == 0:
        #no mutation
        return genome

    elif mutationRate == 1:
        #full mutation
        for value, item in enumerate(genome_list):
            if item == "0":
                mutated_list.append("1")
            elif item == "1":
                mutated_list.append("0")
        return "".join(mutated_list)

    else:
        #some mutation

        amount_to_mutate = int(len(genome) * mutationRate)
        #how many bits are we mutating

        mutations = np.random.choice(len(genome), amount_to_mutate, replace=False)
        #randomly choose what to mutate

        for value, item in enumerate(genome_list):
            #mutate those choices
            if value in mutations:
                if item == "0":
                    mutated_list.append("1")
                elif item == "1":
                    mutated_list.append("0")
            else:
                mutated_list.append(item)

    return "".join(mutated_list)
            

def selectPair(population):
    """

    :param population:
    :return: two genomes from the given population using fitness-proportionate selection. This function should use weightedChoice, which we wrote in class, as a helper function.
    """
    weights = []
    for i in population:
        weights.append(fitness(i))
    
    choice = weightedChoice(population, weights)
    choice2 = weightedChoice(population, weights)

    return choice, choice2
    


def runGA(populationSize, crossoverRate, mutationRate, logFile=""):
    """

    :param populationSize: :param crossoverRate: :param mutationRate: :param logFile: :return: text file in which to
    store the data generated by the GA, for plotting purposes. 

    ​main GA program, which takes the population size, crossover rate (​p​c)​ , and mutation rate (​p​m​) as parameters. 
    The optional ​logFile​ parameter is a string specifying the name of a text file in which to store the data generated 
    by the GA for plotting purposes. When the GA terminates​, this function should return the generation at which the 
    string of all ones was found. The GA should run for 50 generations or until the string of all ones is found. 
    If no solution is found, return None.

    """
    save = True
    if logFile == "":
        save = False
    #if we need to save the file, save it.

    if save:
        savefile = open(logFile, 'a')

    genomeLength = 20
    bestGeneration = -1

    print("Population size: ", populationSize)
    print("Genome length: ", genomeLength)

    population = makePopulation(populationSize, genomeLength)
    generation = 0

    solution = False
    x = 0

    while x <= 50 and solution == False:
        newGeneration = []
        avg, highest = evaluateFitness(population)

        if (highest == genomeLength):
            print("Generation   ", generation, ":", "average fitness ", avg, ", ", " best fitness ", highest)
            bestGeneration = generation
            solution = True
            return bestGeneration

        print("Generation   ", generation, ":", "average fitness ", avg, ", ", " best fitness ", highest)
        if save:
            savefile.write(str(generation)+" "+str(avg)+" "+str(highest)+"\n")
            #savefile.write(str(avg)+",")

        for i in range(int(populationSize/2)):
            childA, childB = selectPair(population)

            if(random.random() < crossoverRate):
                childA, childB = crossover(childA, childB)
            
            childA = mutate(childA, mutationRate)
            childB = mutate(childB, mutationRate)

            newGeneration.append(childA)
            newGeneration.append(childB)

        population = newGeneration

        generation = generation + 1
        x = x + 1

    if save:
        savefile.close()
    return None




if __name__ == '__main__':
    #Testing Code
    #print("Test Suite")
    #GAinspector.test(randomGenome)
    #GAinspector.test(makePopulation)
    #GAinspector.test(fitness)
    #GAinspector.test(evaluateFitness)
    #GAinspector.test(crossover)
    #GAinspector.test(mutate)
    #GAinspector.test(selectPair)




    for i in range(5):
        text = "run" + str(i)+".txt"
        runGA(500, .8, 0.01, text)